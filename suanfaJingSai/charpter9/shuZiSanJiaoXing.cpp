//动态规划

/*

动态规划是一种用途很广的问题求解方法， 它本身并不是一个特定的算法， 而是一种思
想， 一种手段。 下面通过一个题目阐述动态规划的基本思路和特点

 */

/* 
数字三角形问题。 有一个由非负整数组成的三角形， 第一行只有一个数， 除了最下行
之外每个数的左下方和右下方各有一个数

*/

//动态规划的核心是状态和状态转移方程

/*

把当前的位置(i, j)看成一个状态（ 还记得吗？ ），然后定义状态(i, j)的指标函数d(i, j)为从格子(i, j)出发时能得到的最大和
（ 包括格子(i, j)本身的值）。在这个状态定义下， 原问题的解是d(1, 1)。
下面看看不同状态之间是如何转移的。从格子(i, j)出发有两种决策。 如果往左走，则走
到(i＋ 1 , j)后需要求“从(i＋ 1 , j)出发后能得到的最大和”这一问题，即d(i＋ 1 , j)。 类似地， 往图9-2 重叠子问题
右走之后需要求解d(i＋ 1 , j＋ 1)。由于可以在这两个决策中自由选择，所以应选择d(i＋ 1,j)
和d(i＋ 1,j＋ 1)中较大的一个。换句话说，得到了所谓的状态转移方程：

d(i,j) = a(i,j) + max{d(i+1, j),d(i+1,j+1)}

如果往左走，那么最好情况等于(i, j)格子里的值a(i, j)与“从(i＋ 1 , j)出发的最大总和”之
和，此时需注意这里的“最大”二字。如果连“从(i＋ 1,j)出发走到底部”这部分的和都不是最大
的， 加上a(i, j)之后肯定也不是最大的。这个性质称为最优子结构（ optimal substructure） ，
也可以描述成“全局最优解包含局部最优解”。不管怎样，状态和状态转移方程一起完整地描
述了具体的算法。

 */

/*

有了状态转移方程之后， 应怎样计算呢？

方法1： 递归计算。 程序如下（ 需注意边界处理）：

int solve(int i, int j){
return a[i][j] + (i == n ? 0 : max(solve(i＋ 1,j),solve(i＋ 1,j＋ 1)));
}

 */

//这样做是正确的， 但时间效率太低， 其原因在于重复计算

/*

方法2： 递推计算。 程序如下（需再次注意边界处理）：

int i, j;
for(j = 1; j ＜ = n; j＋ ＋ )
    d[n][j] = a[n][j];
for(i = n－ 1; i ＞ = 1; i——)
    for(j = 1; j ＜ = i; j＋ ＋ )
        d[i][j] = a[i][j] ＋ max(d[i＋ 1][j],d[i＋ 1][j＋ 1]);


程序的时间复杂度显然是O(n**2)， 但为什么可以这样计算呢？ 原因在于： i是 逆序枚举
的， 因此在计算d[i][j]前， 它所需要的d[i＋ 1][j]和d[i＋ 1][j＋ 1]一定已经计算出来了;

可以用递推法计算状态转移方程。 递推的关键是边界和计算顺序。 在多数情
况下， 递推法的时间复杂度是： 状态总数×每个状态的决策个数×决策时间。 如果不同状态
的决策个数不同， 需具体问题具体分析。

 */

/*

方法3： 记忆化搜索。 程序分成两部分。 首先用“memset(d,－ 1,sizeof(d));”把d全部初始化
为－ 1， 然后编写递归函数(1)：

int solve(int i, int j){
    if(d[i][j] ＞ = 0)
        return d[i][j];
    return d[i][j] = a[i][j] ＋ (i == n ? 0 : max(solve(i＋ 1,j),solve(i＋ 1,j＋ 1)))

上述程序依然是递归的， 但同时也把计算结果保存在数组d中。 题目中说各个数都是非
负的， 因此如果已经计算过某个d[i][j]， 则它应是非负的。 这样， 只需把所有d初始化为－
1， 即可通过判断是否d[i][j]≥0得知它是否已经被计算过。
最后， 千万不要忘记在计算之后把它保存在d[i][j]中。 根据C语言“赋值语句本身有返回
值”的规定， 可以把保存d[i][j]的工作合并到函数的返回语句中。

上述程序的方法称为记忆化（ memoization） ， 它虽然不像递推法那样显式地指明了计算
顺序， 但仍然可以保证每个结点只访问一次
由于i和j都在1～ n之间， 所有不相同的结点一共只有O(n2)个。 无论以怎样的顺序访问，
时间复杂度均为O(n**2)。 从2**n～ n**2是一个巨大的优化， 这正是利用了数字三角形具有大量重叠
子问题的特点。

 */