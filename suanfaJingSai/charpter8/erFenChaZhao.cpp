//二分查找

/*
逐步缩小范围法是一种常见的思维方法。 二分查找便是基于这种思路， 它遵
循分治三步法， 把原序列划分成元素个数尽量接近的两个子序列， 然后递归查找。 二分查找
只适用于有序序列， 时间复杂度为O(logn)
 */

//尽管可以用递归实现， 但一般把二分查找写成非递归的；
int bsearch(int *A, int x, int y, int v)
{
    int m;
    while (x < y)
    {
        m = x + (y - x) / 2; //取中点
        if (A[m] == v)
            return m;
        else if (A[m] > v)
            y = m;
        else
            x = m + 1;
    }
    return -1;
}
/*
上述while循环常常直接写在程序中。 二分查找常常用在一些抽象的场合， 没有数组A，
也没有要查找的v， 但是二分的思想仍然适用;

 */

/*
二分查找的一种特殊情况
如果数组中有多个元素都是v， 上面的函数返回的是哪一个的
下标呢？ 第一个？ 最后一个？ 都不是。 不难看出， 如果所有元素都是要找的， 它返回的是中
间那一个。 有时， 这样的结果并不是很理想， 能不能求出值等于v的完整区间呢（ 由于已经
排好序， 相等的值会排在一起） ？

 */

int lower_bound(int *A, int x, int y, int v)
{
    int m;
    while (x < y)
    {
        m = x + (y - x) / 2;
        if (A[m] >= v)
            y = m;
        else
            x = m + 1;
    }
    return x;
}

/* 

    下面来分析一下这段程序。 首先， 最后的返回值不仅可能是x, x+1, x+2,…, y-1， 还可能
是y——如果v大于A[y-1]， 就只能插入这里了。 这样， 尽管查找区间是左闭右开区间[x,y)，
返回值的候选区间却是闭区间[x,y]。 A[m]和v的各种关系所带来的影响如下。

    A[m]＝ v： 至少已经找到一个， 而左边可能还有， 因此区间变为[x,m]。

    A[m]＞ v： 所求位置不可能在后面， 但有可能是m， 因此区间变为[x,m]。

    A[m]＜ v： m和前面都不可行， 因此区间变为[m+1,y]。

*/

/*

类似地， 可以写一个upper_bound程序， 当v存在时返回它出现的最后一个位置的后面一
个位置。 如果不存在， 返回这样一个下标i： 在此处插入v（ 原来的元素A[i], A[i+1],…全部往
后移动一个位置） 后序列仍然有序。 不难得出， 只需把"if(A[m]>=v) y=m; else x=m+1;"改
成"if(A[m]<=v) x=m+1; else y=m;"即可。
这样， 对二分查找的讨论就相对比较完整了： 设lower_bound和upper_bound的返回值分
别为L和R， 则v出现的子序列为[L,R)。 这个结论当v不在时也成立： 此时L=R， 区间为空。 这
里实现的lower_bound和upper_bound就是STL中的同名函数

 */

//用“上下界”函数求解范围统计问题的技巧非常有用， 建议读者用心体会左闭右开区间的使用方法和上下界函数的实现细节；