/*归并排序
归并排序有两种做法，一种是递归，另一种是非递归！！！！！
归并排序是稳定的，缺点是需要的空间比较大；
内部排序一般不使用归并排序，外部排序使用较多；


第一种高效排序算法是归并排序。 按照分治三步法， 对归并排序算法介绍如下。

划分问题： 把序列分成元素个数尽量相等的两半。

递归求解： 把两半元素分别排序。

合并问题： 把两个有序表合并成一个。

前两部分是很容易完成的， 关键在于如何把两个有序表合成一个。 
每次只需要把两个序列的最小元素加以比较， 删除其中的较小元素并加入合并后
的新表即可。 由于需要一个新表来存放结果， 所以附加空间为n。

 */

void merge_sort(int *A, int x, int y, int *T)
{
    if (y - x > 1)
    {
        int m = x + (y - x) / 2; //划分
        int p = x, q = m, i = x;
        merge_sort(A, x, m, T); //递归求解
        merge_sort(A, m, y, T); //递归求解
        while (p < m || q < y)
        {
            if (q >= y || (p < m && A[p] <= A[q]))
                T[i++] = A[p++];
            //从左半数组复制到临时空间
            else
                T[i++] = A[q++]; //从右半数组复制到临时空间
        }
        for (i = x; i < y; i++)
            A[i] = T[i]; //从辅助空间复制回A数组
    }
}

/*
代码中的两个条件是关键。 首先， 只要有一个序列非空， 就要继续合并（ while(p<m||
q<y)） ， 因此在比较时不能直接比较A[p]和A[q]， 因为可能其中一个序列为空， 从而A[p]或
者A[q]代表的是一个实际不存在的元素。 正确的方式是：
如果第二个序列为空（ 此时第一个序列一定非空） ， 复制A[p]。
否则（ 第二个序列非空） ， 当且仅当第一个序列也非空， 且A[p]≤A[q]时， 才复制
A[p]。
上面的代码巧妙地利用短路运算符“||”把两个条件连接在了一起： 如果条件1满足， 就不
会计算条件2； 如果条件1不满足， 就一定会计算条件2。 这样的技巧很实用， 请读者细心体
会。 另外， 读者如果仍然不太习惯T[i++]=A[p++]这种“复制后移动下标”的方式， 是时候把它
们弄懂、 弄熟了。
不难看出， 归并排序的时间复杂度和最大连续和的分治算法一样， 都是O(nlogn)的。


 */

//非递归方法
