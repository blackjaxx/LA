//函数和递归

#递归的三大要素

1.明确函数要干什么

我定义了一个函数

    计算n的阶乘

    int f(int n){

    }

2.寻找递归条件

寻找递归结束的条件，否则会无限循环调用,
需要找出当参数为什么时，递归结束，之后直接返回结果;

    int f(int n){
        if(n <= 2)
        {
            return n;
        }
    }

3.找出函数的等价关系式
即不断缩小函数的范围
比如f(n)这个范围比较大，我们知道f(n) = f(n-1) * n;
所以范围变小了;

    int f(int n){

        if(n <= 2)
        {
            return n;
        }

        return f(n - 1) * n
    }

典型题目：

斐波那契数列
青蛙跳台阶
反转单链表

#递归需要优化
否则会有大量重复计算
一般来说有两种优化方法

1.考虑将计算结果保存，常规做法使用hash或者数组保存计算结果
例如对于青蛙跳台阶题
f(n) = f(n-1) + f(n -2)
例如使用arr[n] = f(n)
f(n)没有计算过的时候，让arr[n]都初始化为-1

    memset(arr,-1,sizeof(arr));

    int f(int n)
    {
        if(n <= 1)
        {
            return n;
        }
        //每次计算前先判断一下arr[n]是否被计算过
        if(arr[n] != -1)
        {
            return arr[n];
        }
        else
        {
            //没有被计算过则递归计算，把结果保存在arr[n]中
            arr[n] = f(n - 1) + f(n - 2);
            return arr[n];
        }
    }



2.考虑是否可以自底向上

一般计算递归时自顶向下递归，有时候当n比较大，n=10000层直到n <= 1才将结果慢慢返回，如果n太大导致爆栈
对于这种情况，我们使用自底向上的计算方法

f(1) = 1;

f(2) = 2;

那么推算出f(3) = f(2) +f(1) = 3;

可以一直递推到f(n)

    int f(int n)
    {
        if(n <= 2)
        {
            return n;
        }

        int f1 =1;
        int f2 =2;
        int sum = 0;

        for(int i = 3; i < n; ++i)
        {
            sum = f1 + f2;
            f1 =f2;
            f2 = sum;
        }
        return sum;
    }