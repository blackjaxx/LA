//小球下落
//一颗二叉树深度为D，且所有叶子深度相同，所有节点从上到下，从左到右编号为1，2，3，...2^D - 1，节点1处放一小球会向下落
//节点上都有一开关，初始全部是关闭的，每次有小球到达一个节点时，节点上的开关状态就会改变，如果节点是关闭的，则往左走，反之向右，直到叶子节点
//一些小球从根节点开始下落，最后一个小球会落在哪里呢
//小球个数I不超过叶子个数且D<20即深度小于20，输入最多1000组数据

//叶子个数是2^(d-1)个，除根节点外，每个节点k的左子节点是2k，右子节点是2k+1

/*
样例输入：

4 2
3 4
10 1
2 2
8 128
16 12345

样例输出：

12
7
512
3
255
36358
*/

#include <cstdio>
#include <cstring>
const int maxd = 20;
int s[1 << maxd]; //最大节点个数2^maxd-1,这里对1进行左移maxd位，左移一位代表*2，那么s是数组，左移后是下标为2^maxd - 1
int main()
{
    int D, I;
    while (scanf("%d%d", &D, &I) == 2)
    {
        memset(s, 0, sizeof(s));    //初始化数组中的元素全部为0
        int k, n = (1 << D) - 1;    //n是最后一个叶子节点的编号，如果有4层，根节点从1开始，那么最后一个元素是2^4 - 1 = 15
        for (int i = 0; i < I; i++) //连续小球下落
        {
            k = 1;
            for (;;)
            {
                s[k] = !s[k];                 //拿第一个举例，当小球到根节点时，根节点由0变1
                k = s[k] ? k * 2 : k * 2 + 1; //此时k和s[k]的状态是相等的，那么像左走
                if (k > n)
                    break; //出界了
            }
        }
        printf("%d\n", k / 2); //出界之前的叶子编号
    }
    return 0;
}

//上述程序缺点是运算量巨大
//因为小球最后一定会落在根节点上，那么上两个小球必定是一个在左子树一个在右子树，一般来说，只需要直到此球是第几个落在根的左子树里，就可以知道它的下一步是往左还是往右了
//如果给出编号I，当I是奇数时，它是往左走的第(I+1)/2个小球，如果是偶数编号，它是往右走的第I/2个小球
while (scanf("%d%d", &D, &I) == 2)
{
    int k = 1;
    for (int i = 0; i < D - 1; i++)
    {
        if (I % 2)
        {
            k = k * 2;
            I = (I + 1) / 2;
        }
        else
        {
            k = k * 2 + 1;
            I /= 2;
        }
        printf("%d\n", k);
    }
    //这样节省了一个巨大的数组
}
