//数论初步

// 欧几里德算法和唯一分解定理
/*

除法表达式。 给出一个这样的除法表达式： X1 / X2 / X3 / …/ Xk， 其中Xi是正整数。 除法
表达式应当按照从左到右的顺序求和， 例如， 表达式1/2/1/2的值为1/4。 但可以在表达式中
嵌入括号以改变计算顺序， 例如， 表达式(1/2)/(1/2)的值为1;

输入X1, X2, …, Xk， 判断是否可以通过添加括号， 使表达式的值为整
数。 K≤10000， Xi≤109;


表达式的值一定可以写成A/B的形式： A是其中一些Xi的乘积， 而B是其他数的乘积。 不
难发现， X2必须放在分母位置， 那其他数呢？

幸运的是， 其他数都可以在分子位置：

接下来的问题就变成了： 判断E是否为整数。
第1种方法是利用前面介绍的高精度运算： k次乘法加一次除法。 显然， 这个方法是正确
的， 但却比较麻烦。

第2种方法是利用唯一分解定理， 把X2写成若干素数相乘的形式：

然后依次判断每个 是否是X1X3X4…Xk的约数。 这次不用高精度乘法了， 只需把所
有Xi中pi的指数加起来。 如果结果比ai小， 说明还会有pi约不掉， 因此E不是整数。 这种方法
在第5章中已经用过， 这里不再赘述。
第3种方法是直接约分： 每次约掉Xi和X2的最大公约数gcd(Xi, X2)， 则当且仅当约分结束
后X2=1时E为整数， 程序如下：

int judge(int* X) {
    X[2] /= gcd(X[2], X[1]);
    for(int i = 3; i <= k; i++) 
        X[2] /= gcd(X[i], X[2]);
    return X[2] == 1;
}


整个算法的时间效率取决于这里的gcd算法。 尽管依次试除也能得到正确的结果， 但还
有一个简单、 高效， 而且相当优美的算法——辗转相除法。 它也许是最广为人知的数论算
法。

辗转相除法的关键在于如下恒等式： gcd(a,b) = gcd(b, a mod b)。 它和边界条件gcd(a,
0)=a一起构成了下面的程序：

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a%b);
}

这个算法称为欧几里德算法（ Euclid algorithm） 。 既然是递归， 那么免不了问一句： 会
栈溢出吗？ 答案是不会。 可以证明， gcd函数的递归层数不超过4.785lgN + 1.6723， 其
中N=max{a,b}。 值得一提的是， 让gcd递归层数最多的是gcd(Fn,Fn-1)， 其中Fn是后文要介绍
的Fibonacci数。
 */