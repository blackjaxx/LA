//归并排序（从小到大）
//划分，递归求解，合并
void merge_sort(int *A, int x, int y, int *T) //A是原数组，T是合并后的新数组
{
    if (y - x > 1)
    {
        int m = x + (y - x) / 2; //尽量分成相等的两份
        int p = x, q = m, i = x;
        merge_sort(A, x, m, T); //递归求解左半部分
        merge_sort(A, m, y, T); //递归求解右半部分
        while (p < m || q < y)  //当左半部分或右半部分有元素，逻辑运算符左边为真，那么右边不执行，直接到if中，看看右半部分是不是还有元素
        {
            if (q >= y || (p < m && A[p] <= A[q]))
            {
                T[i++] = A[p++]; //有半部分何并完毕，左半部分还有剩余
            }
            else
            {
                T[i++] = A[q++]; //如果上述条件不满足需要合并右半部分
            }
        }
        for (i = x; i < y; i++) //x没变，还是最左边
        {
            A[i] = T[i]; //从辅助数组复制回原数组
        }
    }
}

//注意逻辑运算符的使用
//时间复杂度O(nlogn)